首先是解析下什么是垃圾？程序在运行过程中，那些曾经申请在堆上存储，并且后续不再使用的对象，就是垃圾。这些垃圾是由系统帮忙回收的吗？不是的，因为我们的垃圾是在堆上存储着的，堆上的内存实际上是由用户程序进行管理的，自然垃圾要由用户程序进行回收，比如Golang，在程序进行启动的时候会启动垃圾回收协程。相对应，自然地，由于堆上的内存是用户管理的，如果用户不主动回收，堆上的内存早晚会被消耗一空。

回收就回收啊，清空堆不就完事了吗？难点远远不止这些。垃圾回收依赖于垃圾回收算法，但是无论基于哪种垃圾回收算法思想，都要做到两点：
第一，要判断对象是否为垃圾。第二，垃圾对象的回收。
标记清除类的算法，把这两个步骤完全的分开，造成STW（stop the world）,即把整个用户的程序给挂起，这对在线服务来说实际上是致命的 。那为什么要让垃圾回收与用户程序分开运行呢？如果交叉在一起跑就会有新的问题产生，比如标记的过程中，有新的对象产生，标记的时候给落下了，那么回收节点会把这些新的对象直接给释放，这是不允许的。

由于STW是很多在线服务不能容忍的，所以后来人基于这样的缺点发明了很多垃圾回收算法，比如标记引用就是把垃圾回收程序“完美”融合到用户程序中，不过同样有缺点。最初版本的Golang采用的就是原始的标记清除，后来基于标记清除进行了改进，即三色标记，目的就是致力于减少STW时间。当然，说了这么多，垃圾回收不只是关注STW时间，还有很多维度，比如回收速度，基于这些指标，，也有很多改进方案，比如节点复制、分代收集。

在正式了解堆跟栈之前，要先说明下Linux的进程是怎么使用物理内存的。有几个名词需要简单解释下：
1. 虚拟内存
在没有虚拟内存之前，所有的进程都是直接使用物理内存，这样是很危险的，某个进程一不小心就访问到了另外一个进程的数据，更严重一点，如果某个进程不小心修改了内核的内存数据，则会引起整个操作系统的崩溃。其次，我们现在很多程序占用的内存很大，而我们的物理内存大小是有限的。
<img src="http://yishon.top/wp-content/uploads/2021/03/image-300x203.png" alt="" width="300" height="203" class="alignnone size-medium wp-image-404" />
CPU想要读取某个虚拟地址的内容，MMU根据虚拟地址定位到页表的索引，根据索引定位到对应的表项，如果该表项的有效位为1，则直接读取右边的物理页号，找到对应的物理页读取内容即可，这就是所谓的页命中。如果标志为0 ，则代表该页并未命中缓存，产生了缺页，则直接从虚拟地址所对应的磁盘中，把该页内容加载到物理内存中去，并且找到一个牺牲页，作为替换则会从物理内存中替换出去，如果该页被修改过，则会写回磁盘。当一个系统需要分配一个新的虚拟页时，则会在磁盘上创建对应的虚拟页空间，更新映射表，指向该磁盘页。以上的操作都会更新对应的映射表。
这里会有一个名词，thrashing,也可以叫做系统颠簸（抖动）。根据虚拟内存，进程在运行中实际上加载在物理内存中的数据只是少部分，但是它运行的还是很好，这要得益于我们的程序运行的局部性原理，所谓局部性原理指的是，我们的程序虽然总体使用的页面个数要很大甚至超过了物理内存大小，但是在某个时刻，它的运行只需要一小部分的活动页面上即可完成，我们把这部分的页面叫做工作集。但是如果我们的工作集的大小超过了我们的进程所占用的物理内存的大小，可想而知，会不断的产生缺页，页面在磁盘与物理内存上换出换入，这就是我们的颠簸现象。
总的来说，虚拟内存的好处可以总结为：
1. 给每个进程提供了一致的地址空间，每个进程都认为自己是在独占使用单机系统的存储资源，这也是虚拟内存的最大的作用。
2. 保护每个进程的地址空间不被其他进程破坏，隔离了进程的地址访问。
3. 根据缓存原理，上层存储是下层存储的缓存，虚拟内存把内存作为磁盘的高速缓存，在主存和磁盘之间根据需要来回传送数据，高效地使用了主存。
