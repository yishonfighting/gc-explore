 前面说了很多关于垃圾回收的其他内容，现在回归垃圾回收本身。所谓垃圾回收，即释放我们不再使用的对象的内存。之前也说过，垃圾回收算法很多，下面会逐一说明下，当然重点还是Golang目前的三色标记法。

了解垃圾回收之前，有三个基础概念，mutator(赋值器)和collector（收集器），这两个名词经常在垃圾 收集算法中出现，collecter指的是垃圾收集器，而mutator是指除了垃圾收集器之外的部分，比如说我们应用程序本身，其次就是根对象roots，我们一般有一个认知，垃圾回收都是回收堆上的内存，那么我们的根对象就是堆之外的并且是被我们的程序访问得到的，比如C++的静态变量，栈上的对象等待。golang的根对象就是协程栈上的指针对象。

一. 标记-清除
标记清除是最简单也是最古老的垃圾回收算法。流程包括：
1. 先从roots开始扫描，当roots指向了某个堆上的对象，我们就认为这个对象是可达的；
2. 可达对象指向的对象也是可达对象；
3. 从roots开始遍历，采用深度/广度优先遍历
<img src="http://yishon.top/wp-content/uploads/2021/03/clean-300x195.png" alt="" width="300" height="195" class="alignnone size-medium wp-image-408" />

上图的C，E就是不可达对象，要被清理掉。
整个流程可以总结为：
1. 触发垃圾回收事件发生，一般是当申请堆内存的时候，做一个检测机制，或者定时回收
2. STW，挂起整个程序，等待GC
3. 从roots开始扫描，在每个可达对象的header做一个标记
4. 清除阶段,扫描整个堆，发现是活跃对象的话，则清除它的标志位。如发现是非活跃对象则把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表就可以找到分块了
5. 清除完成，继续程序。

这个算法的优点就是思想简单，很好实现，但是缺点也很明显，就是很容易产生很多碎片，分配的时候速度比较慢，因为需要遍历空闲链表，最坏的情况是遍历到最后也没有找到合适的。不过列举的这些缺陷都可以使用一些方法缓解，比如合并连续的区域，比如多个空闲链表等，但是我认为标记清除的最大的一个缺点是STW，在很多场景下是不能容忍的，比如：
在标记阶段进行中，程序也在同时跑，这个时候突然创建了一个对象，也是可达的，当标记完D之后，认为到这里就已经完事了，但是我们创建的新对象H就会在清除节点被认为是不可达的，最终被清理掉，同样，清除阶段也会遇到这样的问题。



二、引用计数
引用计数可能是比较多人接触的一种垃圾回收算法，C++的智能指针解放了程序员释放内存的操作，其实它的原理就是引用计数。
1. 我们给每个对象都分配一个计数器，代表有多少其他的对象引用完；
2. 当没有对象再引用我的时候就代表我没用了，就是垃圾可以被回收了

<img src="http://yishon.top/wp-content/uploads/2021/03/count_cir-300x114.png" alt="" width="300" height="114" class="alignnone size-medium wp-image-411" />

跟图片所示的一样，但是有几个点需要注意 ：
1. 当对象刚被创建的时候，它就代表肯定有一个指针指向自己，所以我们对创建的对象设置计数器为1；
2. 那么是否回收操作是发生在引用计数为0的时候呢？当我们遇到某个对象的引用计数为0的时候直接回收就完事了 ？不是的。假定一个场景，当我们要回收对象B时，虽然指向B的引用没有了，但是B指向的对象还是可能存在的，如果我们就直接简单回收掉，就出现B引用的那些对象的计数永远不会0，所以我们要把B所有引用的对象给减1，同样道理，如果B引用的对象被减1后正好变为0，我们需要继续递归地更新计数器；

我们来总结下过程：
1. 当对象被创建的时候，初始化计数器为1；
2. 当更新指针时候，需要检测引用计数是否为0，如果为0就回收掉，放入空闲队列中，并且递归更新；

优缺点也同样很明显：
1. 首先，引用计数方法的垃圾回收不会像标记清除那样，专门去做触发的操作，或者定时清除。而且完全不用专门STW，因为它的 回收操作完全分布在应用程序运行过程中，这是它的最大的优点；
2. 垃圾会立刻被回收，相比较其他的垃圾回收算法，我们一旦发现引用计数为0就立即回收；
3. 但是指针更新的时候需要我们去手动操作，如果漏了一个，就可能会回西安很多无法回收的对象造成内存泄漏；
4. 还有一个问题，就是无法回收循环引用的对象

<img src="http://yishon.top/wp-content/uploads/2021/03/count-300x128.png" alt="" width="300" height="128" class="alignnone size-medium wp-image-412" />

当AB两个对象由左边转换为右边的时候，就会出现A、B永远不会被回收的情况；
5. 在程序中更新指针是一个很频发的操作，相对应的，我们就要频繁更新计数器；
6. 当发现一个对象引用为0的时候，我们需要继续递归去更新计数器。在极端的情况下，这个递归会很深，造成系统的颠簸
7. 同理，也可能是一个极端情况，在一台32位的机器，一个对象假定最多2^32对象引用，那么我们的计数器就应该是一个32位的数据，这是极大的空间浪费。

三、节点复制
标记清除有两个阶段，第一步是找到活跃的对象给它标记上，第二步扫描整个堆，把其余未标记的对象清除掉，这两个步骤能不能节省一个步骤呢？再有就是我们的对象申请的时候都是从空闲链表上获取的，找到一个合适大小的内存块这个速度是比较慢的。但是栈内存的申请是很快的，因为栈是一块连续的空间，申请的时候只需要按照地址增长的大小申请即可，时间复杂度为O(1)。而节点复制就是为了解决这两个问题。

1. 首先它是把堆的内存分为两个部分，并且是均分，一个叫From,一个叫To
2. From内存块就是我们内存分配的时候用的
3. 当我们要进行GC的时候，我们把活跃的对象直接复制到To内存空间去，然后直接把To空间换做我们的程序使用的空间，再把From整体清空，然后再把From作为To。

思路看起来很简单，但是操作起来会有一点复杂。下面的伪代码摘自《垃圾回收的算法与实现》
<code>
copying(){
    $free = $to_start
    for(r : $roots)
        *r = copy(*r)
    swap($from_start, $to_start)
}
copy(obj){
    if(obj.tag != COPIED)
        copy_data($free, obj, obj.size)
        obj.tag = COPIED
        obj.forwarding = $free
        $free += obj.size
    for(child : children(obj.forwarding))
        *child = copy(*child)
    return obj.forwarding
}
</code>

copying函数其实就是我们整体的GC，首先我们把free指针指向To空间的start位置，然后遍历roots，调用copy函数把roots 复制到To空间去，注意下，这里copy函数返回的是对象在新空间的位置，而且copy函数是递归把所有r的对象都复制到新的空间去。copy函数的操作内容如下：

1. 判断对象是否被复制过，如果复制过就直接返回它的新空间的指针。如果未复制，就把对象拷贝到新空间的$free处，然后把其标志位设置为已复制，把forwarding设置为刚才复制的新空间的地址；
2. 当复制完对象之后，再递归把对象指向的所有对象都复制到新空间，并且把指针指向新的地址空间；
3. 最后我们再交换From跟To空间；


<img src="http://yishon.top/wp-content/uploads/2021/03/copy-300x181.png" alt="" width="300" height="181" class="alignnone size-medium wp-image-410" />
<img src="http://yishon.top/wp-content/uploads/2021/03/copy_fin-300x82.png" alt="" width="300" height="82" class="alignnone size-medium wp-image-409" />



如上图，复制完之后就剩余B了，直接清空From空间之后就清除了。

总结下优缺点：
1. 分配速度快，因为没有空闲链表的概念，直接当成一个栈内存分配即可，同时也就没有碎片化的烦恼了；
2. 吞吐量高，其实就是GC速度快，因为它不像标记清除那样进行第二个阶段去扫描所有的堆；
3. 同时，通过老空间的内容复制到新空间之后，相互有引用的对象会被分配在比较近的地方，这其实满足局部性原理，会提升我们的缓存命中率；
4. 但是缺点同样明显，浪费内存，因为只用了一半；
5. 这里面也有递归，同时有可能引起栈溢出；
6. 同样，它也有STW的时间，复制清除的过程需要暂停程序；

四、分代收集
分代收集是一种思想，并非专门的垃圾回收算法。所谓分代，就是把堆分配的对象分代，可以理解为上一代下一代这种感觉。分代是按照垃圾的生命周期来分的，很快就会变成编程垃圾的那种对象被分为年轻的一代，相应的，很长时间才会变成垃圾的对象被称为老一代，我们每次只对年轻一代GC就好了，每次GC都会给对象增加一个年龄，当到达老一代的对象的年龄限制的时候，再把它升级为老对象，放到老对象空间中，当老对象空间满了再去GC老对象即可。下面堆该算法做一个简单分析：

1. 该算法把堆空间分为四个部分：生成空间，幸存空间1，幸存空间2，老年代空间，并且我们把前三者合并为新生代空间；
2. 当对象刚创建的时候，分配的空间就是在生成空间；
3. 当生成空间满的时候，我们就对新生代空间进行GC，这里是对整个新生代空间GC，采用GC的算法就是节点复制
4. 每次GC的时候都会对对象的年龄加1，当判断对象的年龄到达一定阀值时，移动对象到老年代空间；
5. 当我们对新生代对象进行GC的时候，因为存在一种情况，老年代的对象也会指向新生代，为了解决这种情况，用一个记录集来记录那些老年代的对象指向新生代的情况。这样，当我们进行GC新生代的时候，从roots与记录集中就行了，而处理这个记录采用的是写入屏障的方法；
6. 老年代GC采用的是标记清除的方法，这里的清除是对整个堆进行GC

五、三色标记法

在golang1.5之前，主要是采用标记清除的方法，但是STW时间会很长，之后的版本采用了三色标记法，因为golang比较适合网络高并发的服务场景，那么如果使用STW 时间较长的GC算法对服务来说会是致命的。三色标记法的思想其实就是尽量把标记阶段、清除阶段与程序同时跑，它其实是一种增量式GC算法，所谓增量式GC算法其实就是把GC过程拆分出来的意思。所谓的三色标记，我们给对象进行颜色标记，分别是白色、灰色、黑色，在GC开始的时候，所有的对象默认都是白色，所有的可达对象都会被标记为黑色，而灰色就是我们的中间状态，我们GC的roots都在栈上，所谓的栈就是协程栈。

先说明一个点，屏障技术：
当回收器满足下面两种情况之一时，则可保证不会出现对象丢失问题。
弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）
强三色不变式：强制性的不允许黑色对象引用白色对象即可。而弱三色不变式中，黑色对象可以引用白色对象，但是这个白色对象仍然存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。

插入屏障：拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态，这样就不存在黑色对象引用白色对象的情况了，满足强三色不变式，在Golang中，对栈上的指针的写入添加写屏障成本很高，所以Go选择仅对堆上的指针插入添加写屏障，这样就会出现在扫描结束后，栈上仍存在引用白色对象的情况，这时栈是灰色的，不满足三色不变式，所以需要对栈进行重新扫描使其变黑，完成剩余对象的标记，这个过程需要STW，这期间所有goroutine会挂起，当程序较多时，时间可能会达到10～100ms

删除屏障：也是拦截写操作的，但是是通过保护灰色对象到白色对象的路径不会断来实现的。但是回收的精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉，回收器悲观的认为所有被删除的对象都会被黑色对象引用。

Golang1.8版本之后都是采用混合写屏障了。因为插入屏障跟删除屏障各有缺点。插入写屏障在标记开始时无需STW，可直接开始并发进行，但是结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；删除写屏障则需要在GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，但是结束时无需STW。所谓的混合屏障就是结合了删除、插入，结合了两者的优点。伪代码如下：
<code>
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
</code>
这里使用了两个shade操作，shade(*slot)是删除写屏障的变形，例如，一个堆上的灰色对象B，引用白色对象C，在GC并发运行的过程中，如果栈已扫描置黑，而赋值器将指向C的唯一指针从B中删除，并让栈上其他对象引用它，这时，写屏障会在删除指向白色对象C的指针的时候就将C对象置灰，就可以保护下来了，且它下游的所有对象都处于被保护状态。 如果对象B在栈上，引用堆上的白色对象C，将其引用关系删除，且新增一个黑色对象到对象C的引用，那么就需要通过shade(ptr)来保护了，在指针插入黑色对象时会触发对对象C的置灰操作。如果栈已经被扫描过了，那么栈上引用的对象都是灰色或受灰色保护的白色对象了，所以就没有必要再进行这步操作。

Golang中的混合写屏障满足的是变形的弱三色不变式，同样允许黑色对象引用白色对象，白色对象处于灰色保护状态，但是只由堆上的灰色对象保护。由于结合了Yuasa的删除写屏障和Dijkstra的插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间

过程如下：

1. 当GC触发的时候，首先我们会初始化写屏障（golang使用的是混合写屏障，避免了对栈的re-scan过程，极大减少了STW时间）。我们的垃圾回收器从roots对象开始扫描，把所有的垃圾根对象压入一个栈中，并且把对象都会标记为灰色；
2. 从栈中POP出一个对象，把该对象所有指向的子对象都入栈，并且标记为灰色，并且把该对象标记为黑色，然后放入黑色的对象集合中；
3. 无限的重复第二个步骤，直到栈为空；
4. 在第一步中有说到写屏障，这个写屏障其实就是记录我们进行第一次扫描的时候漏掉的那些对内存的操作，我们会再次遍历这些记录，这个过程会STW，但是很短；
5. 扫描所有的堆，把白色对象清除即可





