C/C++中动态分配的内存需要我们手动释放，这么做好处很明显：程序员可以完成掌握内存。但是缺点也很多，比如经常出现忘记释放内存，导致内存泄漏。所以，很多现代语言都加上了垃圾回收机制。


####1. 关于堆栈
栈：可以理解成一次函数调用内部申请到的内存，他们会随着函数的返回把内存还给系统，比如：

```
func F() {
	temp := make([]int, 0, 20)
	...
}
```
类似于上面代码里面的temp变量，只是函数内部申请的临时变量，并不会作为返回值返回，他就是被编译器申请到栈里面。
申请到栈内存的好处是什么呢？函数返回直接释放，不会引起垃圾回收，对性能没有影响。

那么堆呢？
```
func F() []int{
	a := make([]int, 0, 20)
	return a
}
```
上面这段代码，申请的代码是一样的，但是申请后作为返回值返回了，编译器会认为变量之后会被使用，但函数返回之后并不会将其内存归还，那么它就会被申请到堆上面了。
申请到堆上面的内存才会引起垃圾回收，如果这个过程过于高频就会导致GC压力过大，程序性能出问题。

当然还有特殊情况：
```
func F() {
	a := make([]int, 0, 20)     // 栈 空间小
	b := make([]int, 0, 20000) // 堆 空间过大
 
	l := 20
	c := make([]int, 0, l) // 堆 动态分配不定空间
}
```
例子中，b这种即使是临时变量，申请过大也会在堆上面申请，对于c编译器对这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。

堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：PUSH和RELEASE（分配和释放）而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。通过逃逸分析可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆变量少了，会减轻分配堆内存的开销，同时也会减少GC的压力，提高程序的运行速度。

####2. 逃逸分析

是指由编译器决定内存分配的位置，不需要程序员指定。任何时候，一个值被分享到函数栈帧范围之外，它都会在堆上被重新分配。简单来说，编译器会分析代码的特征和代码的生命周期，Go中变量只有在编译器可以证明在函数返回后不会再被引用的，才会分配到栈上，其他情况下都是分配到堆上。Go中没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定变量分配到何处。如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。也就是说，编译器会根据变量是否被外部引用来决定是否逃逸：
如果函数外部没有引用，则优先放在栈中；
如果函数外部存在引用，则必定放到堆中。

在函数中申请一个新的对象：
如果分配在栈中，则函数执行结束可自动将内存回收；
如果分配在堆中，则函数执行结束可交给GC处理。

逃逸分析可以减少GC的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要GC标记清除；
逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好；
同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码会去掉同步锁运行。

####3. 常见情况

指针逃逸，参照例子：
```
package main

type Student struct {
    Name string
    Age  int
}

func StudentRegister(name string, age int) *Student {
    s := new(Student) //局部变量s逃逸到堆

    s.Name = name
    s.Age = age

    return s
}

func main() {
    StudentRegister("Jim", 18)
}
```
栈空间不足逃逸（空间开辟过大），参照例子：
```
package main

func Slice() {
    s := make([]int, 10000, 10000)

    for index, _ := range s {
        s[index] = index
    }
}

func main() {
    Slice()
}
```
动态类型逃逸（不确定长度大小），比如interface类型，不定参（fmt.Println(a ...interface{})）

```
package main

import "fmt"

func main() {
    s := "Escape"
    fmt.Println(s)
}
```
闭包引用对象逃逸
```
func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}

func main() {
    f := Fibonacci()

    for i := 0; i < 10; i++ {
        fmt.Printf("Fibonacci: %d\n", f())
    }
}
```
发送指针的指针或值包含了指针到 channel 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。

slices 中的值是指针的指针或包含指针字段。一个例子是类似[] *string 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。

slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。

调用接口类型的方法。接口类型的方法调用是动态调度 - 实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上。 

尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上

<strong>插播一个问题，函数传递指针真的比传值效率高吗？</strong>

我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。

关于逃逸分析，官网上也有问题答复，翻译了如下：
如何得知变量是分配在栈（stack）上还是堆（heap）上？
准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。
知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。
当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。

